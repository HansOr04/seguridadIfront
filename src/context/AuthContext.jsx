'use client';

import { createContext, useContext, useReducer, useEffect } from 'react';
import { authAPI } from '@/lib/api';
import { 
  getStoredToken, 
  setStoredToken, 
  removeStoredToken, 
  setStoredUser, 
  getStoredUser,
  isTokenExpired 
} from '@/lib/auth';

// Estados del contexto
const initialState = {
  user: null,
  loading: true,
  error: null,
  isAuthenticated: false,
};

// Tipos de acciones
const AUTH_ACTIONS = {
  SET_LOADING: 'SET_LOADING',
  LOGIN_SUCCESS: 'LOGIN_SUCCESS',
  LOGOUT: 'LOGOUT',
  SET_ERROR: 'SET_ERROR',
  CLEAR_ERROR: 'CLEAR_ERROR',
  UPDATE_USER: 'UPDATE_USER',
};

// Reducer para manejar el estado
function authReducer(state, action) {
  switch (action.type) {
    case AUTH_ACTIONS.SET_LOADING:
      return {
        ...state,
        loading: action.payload,
      };

    case AUTH_ACTIONS.LOGIN_SUCCESS:
      return {
        ...state,
        user: action.payload.user,
        isAuthenticated: true,
        loading: false,
        error: null,
      };

    case AUTH_ACTIONS.LOGOUT:
      return {
        ...state,
        user: null,
        isAuthenticated: false,
        loading: false,
        error: null,
      };

    case AUTH_ACTIONS.SET_ERROR:
      return {
        ...state,
        error: action.payload,
        loading: false,
      };

    case AUTH_ACTIONS.CLEAR_ERROR:
      return {
        ...state,
        error: null,
      };

    case AUTH_ACTIONS.UPDATE_USER:
      return {
        ...state,
        user: action.payload,
      };

    default:
      return state;
  }
}

// Crear contexto
export const AuthContext = createContext(null);

// Provider del contexto
export function AuthProvider({ children }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Verificar token al cargar la aplicaci√≥n
  useEffect(() => {
    checkAuthStatus();
  }, []);

  // Verificar el estado de autenticaci√≥n
  const checkAuthStatus = async () => {
    try {
      console.log('üîç AuthContext: Verificando estado de autenticaci√≥n');
      const token = getStoredToken();
      
      if (!token) {
        console.log('‚ùå AuthContext: No hay token almacenado');
        dispatch({ type: AUTH_ACTIONS.SET_LOADING, payload: false });
        return;
      }

      // Verificar si el token ha expirado
      if (isTokenExpired(token)) {
        console.log('‚è∞ AuthContext: Token expirado, removiendo');
        removeStoredToken();
        dispatch({ type: AUTH_ACTIONS.LOGOUT });
        return;
      }

      console.log('üîç AuthContext: Token v√°lido, verificando con servidor');
      
      // Intentar obtener el usuario desde localStorage primero
      const storedUser = getStoredUser();
      if (storedUser) {
        console.log('‚úÖ AuthContext: Usuario encontrado en localStorage');
        dispatch({
          type: AUTH_ACTIONS.LOGIN_SUCCESS,
          payload: { user: storedUser },
        });
        
        // Verificar en background si el token sigue siendo v√°lido
        try {
          const response = await authAPI.verifyToken();
          if (response.data?.data?.user) {
            // Actualizar usuario si hay cambios
            const serverUser = response.data.data.user;
            if (JSON.stringify(storedUser) !== JSON.stringify(serverUser)) {
              console.log('üîÑ AuthContext: Actualizando usuario desde servidor');
              setStoredUser(serverUser);
              dispatch({
                type: AUTH_ACTIONS.UPDATE_USER,
                payload: serverUser,
              });
            }
          }
        } catch (error) {
          console.log('‚ö†Ô∏è AuthContext: Error verificando token en background, pero mantiene sesi√≥n local');
        }
        return;
      }
      
      // Si no hay usuario en localStorage, verificar con el servidor
      try {
        const response = await authAPI.verifyToken();
        
        if (response.data?.data?.user) {
          console.log('‚úÖ AuthContext: Usuario verificado desde servidor');
          const user = response.data.data.user;
          setStoredUser(user);
          dispatch({
            type: AUTH_ACTIONS.LOGIN_SUCCESS,
            payload: { user },
          });
        } else {
          console.log('‚ùå AuthContext: Respuesta de verificaci√≥n inv√°lida');
          removeStoredToken();
          dispatch({ type: AUTH_ACTIONS.LOGOUT });
        }
      } catch (error) {
        console.log('‚ùå AuthContext: Error verificando con servidor');
        removeStoredToken();
        dispatch({ type: AUTH_ACTIONS.LOGOUT });
      }
    } catch (error) {
      console.error('üí• AuthContext: Error verificando autenticaci√≥n:', error.message);
      removeStoredToken();
      dispatch({ type: AUTH_ACTIONS.LOGOUT });
    }
  };

  // Funci√≥n de login
  const login = async (credentials) => {
    try {
      console.log('üöÄ AuthContext: Iniciando login con:', { email: credentials.email });
      
      dispatch({ type: AUTH_ACTIONS.SET_LOADING, payload: true });
      dispatch({ type: AUTH_ACTIONS.CLEAR_ERROR });

      console.log('üì° AuthContext: Llamando a authAPI.login...');
      const response = await authAPI.login(credentials);
      
      console.log('üì• AuthContext: Respuesta de Axios recibida:', {
        hasResponse: !!response,
        status: response?.status,
        statusText: response?.statusText,
        hasData: !!response?.data,
        responseKeys: response ? Object.keys(response) : []
      });

      // IMPORTANTE: Axios pone la respuesta del servidor en response.data
      const serverData = response.data;
      
      console.log('üîç AuthContext: Datos del servidor:', {
        hasServerData: !!serverData,
        serverStatus: serverData?.status,
        serverMessage: serverData?.message,
        hasDataField: !!serverData?.data,
        serverDataKeys: serverData ? Object.keys(serverData) : [],
        dataFieldKeys: serverData?.data ? Object.keys(serverData.data) : []
      });

      console.log('üîç AuthContext: Verificando tokens:', {
        hasTokensInServerData: !!serverData?.data?.tokens,
        hasAccessTokenDirect: !!serverData?.data?.access_token,
        hasAccessTokenInTokens: !!serverData?.data?.tokens?.access_token,
        accessTokenType: typeof (serverData?.data?.access_token || serverData?.data?.tokens?.access_token),
        accessTokenLength: (serverData?.data?.access_token || serverData?.data?.tokens?.access_token)?.length || 0
      });

      // Verificar la estructura correcta: Buscar el token en ambas ubicaciones posibles
      let accessToken = null;
      let user = null;

      if (serverData?.status === 'success' && serverData?.data) {
        // Buscar token en data.access_token (formato del backend corregido)
        if (serverData.data.access_token) {
          console.log('‚úÖ AuthContext: Token encontrado en access_token directo');
          accessToken = serverData.data.access_token;
          user = serverData.data.user;
        }
        // Buscar token en data.tokens.access_token (formato alternativo)
        else if (serverData.data.tokens?.access_token) {
          console.log('‚úÖ AuthContext: Token encontrado en tokens.access_token');
          accessToken = serverData.data.tokens.access_token;
          user = serverData.data.user;
        }
      }

      if (accessToken && user) {
        console.log('‚úÖ AuthContext: Token y usuario encontrados, guardando...');
        setStoredToken(accessToken);
        setStoredUser(user);
        
        dispatch({
          type: AUTH_ACTIONS.LOGIN_SUCCESS,
          payload: { user },
        });

        console.log('üéâ AuthContext: Login exitoso completado');
        return { success: true, user };
      } else {
        console.log('‚ùå AuthContext: Estructura de respuesta incorrecta');
        console.log('üìã AuthContext: Estructura completa:', {
          serverData: JSON.stringify(serverData, null, 2)
        });
        throw new Error('No se recibi√≥ token de acceso v√°lido');
      }
    } catch (error) {
      console.log('üí• AuthContext: Error en login:', {
        message: error.message,
        name: error.name,
        hasResponse: !!error.response,
        responseStatus: error.response?.status,
        responseData: error.response?.data,
        isAxiosError: error.isAxiosError || false
      });

      const errorMessage = error.response?.data?.message || 
                          error.message || 
                          'Error al iniciar sesi√≥n';
      
      dispatch({
        type: AUTH_ACTIONS.SET_ERROR,
        payload: errorMessage,
      });

      return { success: false, error: errorMessage };
    }
  };

  // Funci√≥n de registro de organizaci√≥n
  const registerOrganization = async (organizationData, userData) => {
    try {
      console.log('üè¢ AuthContext: Iniciando registro de organizaci√≥n');
      dispatch({ type: AUTH_ACTIONS.SET_LOADING, payload: true });
      dispatch({ type: AUTH_ACTIONS.CLEAR_ERROR });

      const response = await authAPI.registerOrganization({
        organization: organizationData,
        user: userData,
      });

      const serverData = response.data;

      // Usar la misma l√≥gica de b√∫squeda de token que en login
      let accessToken = null;
      let user = null;

      if (serverData?.status === 'success' && serverData?.data) {
        if (serverData.data.access_token) {
          accessToken = serverData.data.access_token;
          user = serverData.data.user;
        } else if (serverData.data.tokens?.access_token) {
          accessToken = serverData.data.tokens.access_token;
          user = serverData.data.user;
        }
      }

      if (accessToken && user) {
        console.log('‚úÖ AuthContext: Registro exitoso, guardando token');
        setStoredToken(accessToken);
        setStoredUser(user);
        
        dispatch({
          type: AUTH_ACTIONS.LOGIN_SUCCESS,
          payload: { user },
        });

        return { 
          success: true, 
          user,
          organization: serverData.data.organization 
        };
      } else {
        throw new Error('No se recibi√≥ token de acceso');
      }
    } catch (error) {
      console.log('üí• AuthContext: Error en registro:', error.message);
      const errorMessage = error.response?.data?.message || 
                          error.message || 
                          'Error al registrar organizaci√≥n';
      
      dispatch({
        type: AUTH_ACTIONS.SET_ERROR,
        payload: errorMessage,
      });

      return { success: false, error: errorMessage };
    }
  };

  // Funci√≥n de logout
  const logout = async () => {
    try {
      console.log('üö™ AuthContext: Iniciando logout');
      await authAPI.logout();
    } catch (error) {
      console.error('üí• AuthContext: Error al hacer logout:', error.message);
    } finally {
      console.log('üßπ AuthContext: Limpiando datos locales');
      removeStoredToken();
      dispatch({ type: AUTH_ACTIONS.LOGOUT });
    }
  };

  // Actualizar perfil de usuario
  const updateProfile = async (profileData) => {
    try {
      console.log('‚úèÔ∏è AuthContext: Actualizando perfil');
      const response = await authAPI.updateProfile(profileData);
      
      const updatedUser = response.data.data.user;
      setStoredUser(updatedUser);
      
      dispatch({
        type: AUTH_ACTIONS.UPDATE_USER,
        payload: updatedUser,
      });

      return { success: true, user: updatedUser };
    } catch (error) {
      console.log('üí• AuthContext: Error actualizando perfil:', error.message);
      const errorMessage = error.response?.data?.message || 
                          'Error al actualizar perfil';
      
      return { success: false, error: errorMessage };
    }
  };

  // Cambiar contrase√±a
  const changePassword = async (passwordData) => {
    try {
      console.log('üîê AuthContext: Cambiando contrase√±a');
      const response = await authAPI.changePassword(passwordData);
      return { success: true, message: response.data.message };
    } catch (error) {
      console.log('üí• AuthContext: Error cambiando contrase√±a:', error.message);
      const errorMessage = error.response?.data?.message || 
                          'Error al cambiar contrase√±a';
      
      return { success: false, error: errorMessage };
    }
  };

  // Recuperar contrase√±a
  const forgotPassword = async (email) => {
    try {
      console.log('üìß AuthContext: Enviando email de recuperaci√≥n');
      const response = await authAPI.forgotPassword({ email });
      return { success: true, message: response.data.message };
    } catch (error) {
      console.log('üí• AuthContext: Error en recuperaci√≥n:', error.message);
      const errorMessage = error.response?.data?.message || 
                          'Error al enviar email de recuperaci√≥n';
      
      return { success: false, error: errorMessage };
    }
  };

  // Resetear contrase√±a
  const resetPassword = async (token, newPassword) => {
    try {
      console.log('üîÑ AuthContext: Reseteando contrase√±a');
      const response = await authAPI.resetPassword({ token, newPassword });
      return { success: true, message: response.data.message };
    } catch (error) {
      console.log('üí• AuthContext: Error reseteando contrase√±a:', error.message);
      const errorMessage = error.response?.data?.message || 
                          'Error al resetear contrase√±a';
      
      return { success: false, error: errorMessage };
    }
  };

  // Limpiar errores
  const clearError = () => {
    console.log('üßπ AuthContext: Limpiando errores');
    dispatch({ type: AUTH_ACTIONS.CLEAR_ERROR });
  };

  // Valor del contexto
  const value = {
    // Estado
    user: state.user,
    loading: state.loading,
    error: state.error,
    isAuthenticated: state.isAuthenticated,
    
    // Funciones
    login,
    logout,
    registerOrganization,
    updateProfile,
    changePassword,
    forgotPassword,
    resetPassword,
    clearError,
    checkAuthStatus,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}